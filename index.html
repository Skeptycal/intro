<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Mikkel Christiansen" />
  <title>Introduction to Haskell</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Introduction to Haskell</h1>
    <h2 class="author">Mikkel Christiansen</h2>
    <h3 class="date">House4Hack, August 2015</h3>
</section>

<section id="objectives" class="slide level2">
<h1>Objectives</h1>
<p>To teach enough for you to start a project in Haskell.</p>
</section>
<section id="agenda" class="slide level2">
<h1>Agenda</h1>
<ul>
<li>Get Started with the Project</li>
<li>Cover the essential Haskell Tools</li>
<li>Teach the basic syntax and elements of the Haskell language</li>
<li>Point to learning resources</li>
</ul>
</section>
<section id="approach" class="slide level2">
<h1>Approach</h1>
<ul>
<li>Ask questions any time</li>
<li>Test code and look up documentation as we go</li>
<li>Break and fix the project</li>
<li>Let ghc be your teacher!</li>
</ul>
</section>
<section><section id="get-started-with-the-project" class="titleslide slide level1"><h1>Get Started with the Project</h1></section><section id="the-intro-project" class="slide level2">
<h1>The Intro Project</h1>
<p>A small web service.</p>
<ul>
<li>Displays html pages</li>
<li>Has JSON API</li>
<li>In-memory store for (x,y) points</li>
<li>Can do some aggregation on points</li>
<li>Lots of room for improvements!</li>
</ul>
</section><section id="install-tools" class="slide level2">
<h1>Install Tools</h1>
<p>Version control: git (optional)</p>
<p>Get compiler: ghc</p>
<p>Get build manager: cabal || cabal-install</p>
<p>On Debian/Ubuntu it can be done with:</p>
<pre><code>sudo apt-get install git ghc cabal-install</code></pre>
</section><section id="download-project" class="slide level2">
<h1>Download Project</h1>
<p>Clone repository and tell <code>cabal</code> to start fetching dependencies.</p>
<pre><code>$ git clone git@github.com:mschristiansen/intro.git
$ cd intro
$ cabal sandbox init
$ cabal install --dependencies-only --enable-tests
$ cabal test
$ cabal run</code></pre>
</section></section>
<section><section id="haskell-tools" class="titleslide slide level1"><h1>Haskell Tools</h1></section><section id="using-cabal" class="slide level2">
<h1>Using Cabal</h1>
<p>Cabal is a build manager that handles library dependencies.</p>
<p>Dependencies are fetched from <a href="http://hackage.haskell.org">Hackage</a>.</p>
<p>Use Hackage to browse reference documentation and find libraries.</p>
<p>Our project is defined in <code>intro.cabal</code>.</p>
<p>Let's have a look...</p>
</section><section id="using-ghci" class="slide level2">
<h1>Using GHCi</h1>
<p>GHC interactive. A Haskell REPL.</p>
<pre><code>$ ghci
GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help
Prelude&gt; _</code></pre>
<p>In a project you can import all the project dependencies if you do it like this:</p>
<pre><code>$ cabal repl
</code></pre>
<p>The <a href="http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html">Prelude</a>?</p>
</section><section id="ghci-commands" class="slide level2">
<h1>GHCi Commands</h1>
<p>GHCi will try to evaluate expressions not starting with colon.</p>
<pre><code>&gt; 2 + 2                     -- evaluates to 4
&gt; let square x = x * x      -- define that two expressions are equivalent
&gt; square 2                  -- square 2 = 2 * 2
&gt; :?                        -- display help
&gt; :t &#39;a&#39;                    -- to get type information about character &#39;a&#39;
&gt; :l Intro                  -- to load module Intro
&gt; :m +Data.List             -- import module Data.List
&gt; :set -XOverloadedStrings  -- enable language extension
&gt; :q                        -- to quit</code></pre>
</section></section>
<section><section id="syntax" class="titleslide slide level1"><h1>Syntax</h1></section><section id="basic-syntax" class="slide level2">
<h1>Basic Syntax</h1>
<pre><code>&gt; &quot;Hello World&quot;
&gt; print &quot;Hello World!&quot;
&gt; length &quot;Hello World&quot;
&gt; let hello = &quot;Hello World&quot; in print hello
&gt; 1 + 3 * 3                               -- infix notation
&gt; (1 + 3) * 3                             -- precedence
&gt; 1 + 3 $ * 4                             -- &#39;$&#39; instead of parenthesis
&gt; (+) 1 3                                 -- prefix an infix fn
&gt; (+ 1) 3                                 -- partial application
&gt; let { x = a + b where a = 1; b=2 } in x -- semicolon and brackets
&gt; let add a b = a + b                     -- define prefix addition
&gt; let add1 a b = (+) a b                  -- f(x,y) = g(x,y) &lt;=&gt; f = g
&gt; let add2 = (+)
&gt; add 3 4
&gt; 3 `add` 4                               -- infix a prefix fn
&gt; let inc = \i -&gt; i + 1                   -- lambda fn
&gt; let triple = \x y z -&gt; (x,y,z)          ---lambda with multiple args</code></pre>
</section><section id="list-syntax" class="slide level2">
<h1>List Syntax</h1>
<p>Lists are always homogeneous.</p>
<p>Variables are camelCase.</p>
<pre><code>&gt; [1, 3, 4, 5] == (1:3:4:[5])                  -- True
&gt; [2,4..10]                                    -- Even numbers from 2 to 10
&gt; let smallCaps = [&#39;a&#39;..&#39;z&#39;]                   -- Characters
&gt; head smallCaps : tail smallCaps == smallCaps -- True
&gt; let integers = [1..]                         -- infinite lists
&gt; let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
&gt; let square x = x * x
&gt; take 5 $ drop 100 $ map square $ filter (not . even) integers
&gt; [ y : show x | x &lt;- [1..5], y &lt;- smallCaps, even x ]
&gt; foldl&#39; (+) 0 [2,4..10]
&gt; foldl&#39; (++) &quot;&quot; [&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;]
&gt; concat [&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;]
&gt; concatMap show [10..20]</code></pre>
</section><section id="pattern-matching" class="slide level2">
<h1>Pattern Matching</h1>
<p>Multi-line definitions are cumbersome in ghci.</p>
<p>Type in <code>Scratch.hs</code> instead and reload.</p>
<pre><code>&gt; len :: [a] -&gt; Integer              -- our own recursive length function.
&gt; len []     =  0
&gt; len (x:xs) =  1 + length xs
&gt;
&gt; interl [] [] = []
&gt; interl (x:xs) (y:ys) = x : y : interl xs ys
&gt;
&gt; isA &quot;A&quot; = True
&gt; isA _   = False
&gt;</code></pre>
</section><section id="conditionals" class="slide level2">
<h1>Conditionals</h1>
<pre><code>&gt; if null [] then &quot;nothing&quot; else &quot;something&quot;  -- predicate (null [] == True)
&gt;
&gt; null xs | xs == []  = True  -- using a guard in fn definition
&gt; null xs | otherwise = False -- could have pattern matched directly on []

&gt; null = cond xs of
&gt;         [] -&gt; True
&gt;         _  -&gt; False</code></pre>
</section><section id="types" class="slide level2">
<h1>Types</h1>
<p>Always starts with a capital letter.</p>
<p>Type has a constructor typically named same as type.</p>
<pre><code>&gt; type Years = Int

&gt; newtype Name = Name { unName :: String }

&gt; data User = User Years Name
&gt; data User2 = User2 { userAge :: Years, userName :: Name } -- record

&gt; let mikkel = User 36 (Name &quot;Mikkel&quot;)
&gt; let mikkel2 = User2 36 (Name &quot;Mikkel&quot;)
&gt; let mikkel3 = User2 { userAge = 36, userName = (Name &quot;Mikkel&quot;)}

&gt; data colors = Red | Blue | Green                       -- a sum type
&gt; data Request = GET String | PUT String | POST String deriving (Show, Eq)

&gt; instance Show User where
&gt;   show (User age name) = unName name ++ &quot; is &quot; ++ show age ++ &quot; old.&quot;
</code></pre>
<p>Type classes is for sharing an interface between types.</p>
<p>Can generally be derived. Most common Show, Read, Eq, Ord, Bounded.</p>
</section><section id="maybe-and-either" class="slide level2">
<h1>Maybe and Either</h1>
<p>In the Prelude in modules: Data.Maybe and Data.Either.</p>
<p>Often used with fmap, (&lt;$&gt;), and (*) from Control.Applicative.</p>
<pre><code>&gt; data Maybe a = Nothing | Just a
&gt;
&gt; (+1) &lt;$&gt; Just 3                -- Just 4
&gt; fmap (+1) Just 3               -- Just 4
&gt; (+)  &lt;$&gt; Just 4 &lt;*&gt; Just 5     -- Just 9
&gt; (++) &lt;$&gt; Just 3 &lt;*&gt; Nothing    -- Nothing
&gt;
&gt; data Either a b = Left a | Right b
&gt;
&gt; (++) &lt;$&gt; Right &quot;Hello &quot; &lt;*&gt; Right &quot;World&quot;  -- Right &quot;Hello World&quot;
&gt; (+1) &lt;$&gt; Left 4                            -- Left 4
&gt; (+1) &lt;$&gt; Right 4                           -- Right 5
&gt; (+)  &lt;$&gt; Left &quot;Not a number&quot; &lt;*&gt; Right 3   -- Left &quot;Not a number&quot;
</code></pre>
</section><section id="side-effects" class="slide level2">
<h1>Side Effects</h1>
<p>Side effects only happens in the IO Monad. Once impure you can never be pure again.</p>
<p>Think of it as a special type that you wrap and unwrap.</p>
<pre><code>&gt; Int -&gt; Int               -- Pure: Always same output for same input
&gt; Int -&gt; IO Int            -- Impure: Hard to test or reason about.

&gt; main :: IO ()
&gt; main = do                -- Do syntax for sequencing side effects.
&gt;  print &quot;Hello World&quot;     -- Always from top to bottom.
&gt;  print &quot;Good Morning!&quot;
&gt;  return ()               -- Return &#39;exits&#39; the Monad.

&gt; main2 = print &quot;Hello World&quot;

&gt; main3 :: IO Int
&gt; main3 = return 4</code></pre>
</section></section>
<section><section id="return-to-the-intro-project" class="titleslide slide level1"><h1>Return to the Intro Project</h1></section><section id="the-modules" class="slide level2">
<h1>The Modules</h1>
<ul>
<li>Types.hs -- Definition of Project Types</li>
<li>Pages.hs -- Some html pages</li>
<li>Store.hs -- A basic data store based on STM and Data.IntMap</li>
<li>Intro.hs -- Route definitions</li>
</ul>
</section><section id="create-an-address-book" class="slide level2">
<h1>Create an Address Book</h1>
<ul>
<li>Create an &quot;addressbook&quot; route in Intro.hs</li>
<li>Create a static page for route in Pages.hs</li>
<li>Create a Person type in Types.hs</li>
<li>Create some static entries in Store.hs (don't use STM yet.)</li>
<li>List the entries on the addressbook page.</li>
<li>Store the entries in a (Map Name Person)</li>
<li>Create routes for &quot;adressbook/:name&quot;</li>
<li>Add ability to add, remove, search, addresses.</li>
</ul>
</section></section>
<section><section id="learning-resources" class="titleslide slide level1"><h1>Learning Resources</h1></section><section id="learn-you-a-haskell-for-great-good" class="slide level2">
<h1>Learn You a Haskell for Great Good!</h1>
<p>Basic introduction. The place where most people start.</p>
<p>Book can be read for free online or bought in hardcopy.</p>
<p><a href="http://learnyouahaskell.com/">Learn You a Haskell for Great Good!</a></p>
</section><section id="real-world-haskell" class="slide level2">
<h1>Real World Haskell</h1>
<p>Practical examples of fairly large applications in Haskell.</p>
<p>Book can be read for free online or bought in hardcopy.</p>
<p><a href="http://book.realworldhaskell.org/">Real World Haskell</a></p>
</section><section id="lambda-luminaries-meetup" class="slide level2">
<h1>Lambda Luminaries Meetup</h1>
<p>Active functional programming community that meet once a month. Generally at <a href="http://www.house4hack.co.za/">house4hack</a>.</p>
<p><a href="http://www.meetup.com/lambda-luminaries/">Lambda Luminaries</a></p>
</section><section id="reddit" class="slide level2">
<h1>Reddit</h1>
<p>Very active community on Reddit.</p>
<p><a href="https://www.reddit.com/r/haskell">Haskell Subreddit</a></p>
</section></section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
